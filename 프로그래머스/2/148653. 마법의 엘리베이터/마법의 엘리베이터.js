function solution(storey) {
    // 0층으로 가기위한 돌의 최솟값을 어떻게 찾을 수 있을까?
    // 0으로 만드는 법을 찾고, 그들을 비교해야 할까?
    // 16, 2554를 보면서 생각해보자.
    // 16을 10으로 나눴을때 몫은 1이고 나머지는 6이다. 1 + 6 =7 
    // 16에 4를 더하고 10으로 나눈다면 몫은 2이다. 4 + 2 = 6
    // 더할지, 뺄지를 정해야 한다. 
    
    // 만약 13이라고 해보자. 그렇다면 -1 3번, -10 한번이 낫다. => 4번
    // 7을 더하고 -10을 2번 하는 것보다. => 9번
    
    //만약 15라면 10으로 나누면 몫은 1 -1을 5번하면 된다. 6번
    // +1을 5번하고 10으로 나누면 몫은 2이이다. 7번
    // 과반수를 넘기면 더해야 한다.
    
    // 2554라면 1000 으로 나누면 몫은 2, 나머지 554, 과반수 이상이므로 나눈다.
    // 554를 100으로 나누면 몫은 5, 나머지 54, 과반수 이상이므로 나눈다.
    // 54를 10으로 나누면 몫은 5, 나머지 4
    // 몫과 최종 나머지를 더하면 된다. 16이다. 
    
    // 만약 2654라면 어떻게 할거지?
    // 2654를 1000으로 나눈다. 몫은 2이고 나머지는 654이다. 
    // 654를 100으로 나누면 몫은 6이고 나머지는 54이다.
    // 54를 10으로 나누면 몫은 5이고 나머지는 4이다.
    // 그렇다면 몫과 최종 나머지를 더하면 17이다.
    // 두번째 방법 
    // 2654를 1000으로 나누면 몫은 2이고 나머지는 654이다. 
    // 100을 4번 더한다. 1054이다. 여기서 1000으로 나눈다. 몫은 1이고 나머지는 54이다.
    // 이후는 1번째와 같다...
    // 모두 더하면 2 + 4 + 1 + 5 + 4 = 16이다. 
    // 하나의 규칙을 찾을 수 있다. 
    // 첫번째 자릿수의 수가 5보다 크다면 자릿수가 넘어 갈때까지 더해야한다. 
    // 16을 다시 해보자. 10으로 나눈다. 몫은 1이다. 나머지는 6이다. 여기서 1을 4번 더한다.
    // 10이된다. 10으로 나눈다. 몫은 1이다. 나머지는 0이다. 
    // 다 더한다. 1 + 4 + 1 
    // 나누었을때 나머지로 판단하면 될 것이다.
    
    // 이러한 로직을 어떻게 적용할 수 있을까?
    // 만약 1의 자리라면 1로 나누었을때의 나머지로 판단한다.
    // 4일때 4로 나누었을때 몫은 4이고 나머지는 0이니 합을 구하면 4이다.
    // 6이라면 4를 더하고, 10으로 나누면 몫은 1이고 나머지는 0이니 다 더하면 5이다.
    // 덧셈과 나눗셈으로 판단 할 수 있다.
    
    // 판단을 어떻게 할 수 있을까.
    // 반복문으로 판단을 해야 하지 않을까.
    // 10 ** 1보다 같거나 작으면 1자리로 생각하고 연산해야 한다. 
    // 10과 같다면 10으로 나누면 되는 것이고. 같지 않다면 10과 차이를 연산하여 진행한다. 
    // 차이를 무조건 이용해야 한다. 
    // 자릿수를 어떻게 파악할 수 있을까.
    
    // 각 자릿수만 파악할 수 있으면 되는 것 아닌가.
    
    // 56 과 16을 비교해보자.
    // 56이라면 5+6이 안된다. 일의 자리에 4를 더한다. 60 60이 된다. 6과 4를 더한다.
    // 10이 된다. 4와 6과 0을 더한다.
    // 356이라면 3+5+6=14 이 아니라. 4를 더하여 360으로 4+ 3+ 6=13이 된다.
    // 389라면 3 + 8 + 9 = 20 가 아니라. 1을 더하면 390, 1을 더하면 400이 된다. 1 + 1 + 4 +0 +0 으로 6이 된다. 
    // 배열로 가져와 각 자릿 수별로 연산 하면 될 것이다. 
    // 뒤에서 부터 각 자리를 연산 하면 되겠다. 
    // 배열로 만들고 6이상일 경우 다음 배열에 수를 넣어 주면 될것이다.
//     let myInt = 235345;
//     let myFunc = num => Number(num);
//     let intArr = Array.from(String(storey), myFunc);
    
//     console.log(intArr);
//     // 뒤에서 부터 반복하여 6보다 크면 10과의 차이를 답에 더하고 이전 수에 1을 더한다.
//     // 올림을 해준다.
//     // 만약 10이 된다면 10과의 차이가 0이고 올림이 되는 문제는 없다.
//     // 뒤에서부터 반복문을 돌리면 될 것이다.
//     // 만약 첫번째 자릿수가 올림이 되면 그 부분은 올림이 되지 않는다. 
//     // 배열을 뒤집고 배열을 만들어 가면서 해야 하는 건가??
//     // 올림이 되지 않는 경우를 판단해야 한다. 
//     let answer = 0;
//     for(let i = intArr.length -1; i >= 0 ; i --){
//         // console.log("intArr[i]:",intArr[i])
//         if(intArr[i] > 5){
//             console.log(10 - intArr[i])
            
//             answer += 10 - intArr[i];
//             intArr[i-1] ++
//         }else{
//             console.log("5이하일때 요소의 값 :", intArr[i])
//             answer += intArr[i]
//         }
//         console.log("answer:",answer,"intArr[i]:",intArr[i])
        
//     }
//     console.log(intArr)
//     return answer
    // 배열을 새로 만들고 나서 연산을 할까
    // 새로 배열을 만들고 한번에 더하는 것을 생각해보자.
    // 배열의 자리가 하나더 필요한 경우
    // 더하지 않아도 이미 올림이 된 경우, 이미 10인 경우 
    
    // 계속 각 자리를 가져와서 연산을 진행하면 되지 않을까...
    // while문을 사용한다.
    // 원본 값을 수정하여 연산을 진행한다. 문자열로 변환하고 끝 자리에 도달 할때 까지 연산한다.
    
    // 10으로 계속 나눈다. 
    let answer = 0
    while(true){
    // 10으로 연산한다.
    // 나머지가 5보다 크다면 10과의 차이를 answer에 더한다.
    // 그리고 몫에 1을 더하여 재할당한다.
    // 5보다 작다면 그냥 나머지를 answer를 넣는다.
    // 몫에 연산을 반복한다.
    // 몫이 0이 될때까지 반복한다.
        let rem = storey % 10
        if (rem > 5){
            answer += 10 - rem 
            storey = Math.trunc(storey/10) + 1
        }else if(rem == 5){
            // 다음 자릿수의 수가 5이상일 경우 올림을 해줘야 한다.
            answer += rem
            if(Math.trunc(storey/10)%10 >= 5){
                storey = Math.trunc(storey/10) + 1
            }else{
                storey = Math.trunc(storey/10)
            }
        }
        else{
            answer += rem 
            storey = Math.trunc(storey/10)
        }
        if(storey == 0 && rem < 5){
            break
        }
        console.log("rem:",rem,"storey:",storey)
    }
  return answer

}