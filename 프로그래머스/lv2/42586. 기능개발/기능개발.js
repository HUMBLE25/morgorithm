function solution(progresses, speeds) {
    //수도코드
    //진동가 100%일때 기능을 서비스를 반영한다.
    //기능개발은 각각 다르게 된다. => 하지만 뒤에 있는 기능은 앞에 있는 기능이 배포될때 함께 배포된다.
    //배포순서가 정해진 진도가 담긴 배열을 입력받고 작업속도가 담긴 배열도 입력받는다.
    //각각의 배포마다 몇개의 기능이 배포되는지 반환하라
    //배포는  하루에 한번만 가능하다.하루의 끝에 진행된다.
    //날짜를 기준으로 진행도를 증가시키면 되겠다.
    //앞선 기능이 완성되지 않는다면 뒤의 기능이 완성되더라도 배포 하지 않는다.
    
    //1.기능이 완성되면 배포한다.
    //2.앞의 기능이 완성되지 않았다면 배포하지 않는다. 앞의 기능이 완성되어야 배포한다.
    // => 기능의 완성에 걸리는 시간을 담은 배열을 만들어 내자.
    //함수형 프로그래밍으로 만들어 보자.
    
    
    //Math.ceil()
    //사고의 기준
    //날짜?,기능의 완성도? 이둘을 같이 고려 해야 한다.
    
    //완성된 날짜를 담은 배열을 만들자.
    const days=progresses.map((el,id)=>{
        return Math.ceil((100-el)/speeds[id])
    })
    console.log(days)
    //재귀 함수로 가능하지 않을까?
    //로직을 다시 짠다!!!
    //큰 수가 있으면 거기 전까지만 계산해야하한다.
    //마지막 인덱스는 어떻게 계산 할거지? 누산하는것이라 생각해서 reduce로 접근했었다.
    //하지만 자신보다 큰수를 만나는것을 기준으로 하는것이 맞을까? 마지막 인덱스까지 자신보다 큰수가 없다면 
    // 계산이 끝나는 기준은 처음 수보다 큰 수를 만났을떄 그때까지 누산한것을 배열에 넣어주고,
    // 처음수를 그 큰수로 재할당 해준다. 
    // 이를 반복 한다. 헌데 마지막 인덱스까지 보다 큰수가 없을 경우 그때의 누산값을 배열에 넣어준다.
    
    let first = days[0]
    let answer = []
    days.reduce((acc,cur,i)=>{
        // console.log('acc:',acc,'cur:',cur,i)
        // 처음 수보다 현재 수가 크다면 현재수를 처음수에 할당해준다.
        //그때까지의 누산값을 배열에 담아준다.
        if(i >=1 && cur > first){
           
            answer.push(acc)
            first = cur 
            
            if(i===days.length-1){
                console.log('acc:',acc,'cur:',cur,i, days.length-1)
                answer.push(1)
            }
            return acc = 1
        }else{
            // 작은경우
            //1씩 누산해준다.
            
            if(i === (days.length-1)){
                
                answer.push(acc+1)
            }
            
            return acc +1
        }
    },0)
    console.log(answer)
    return answer
    

    
}