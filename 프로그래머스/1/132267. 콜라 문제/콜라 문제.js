function solution(a, b, n) {
    // 2개를 가져다 주면 1개를 주는 마트일 경우
    // 빈병을 짝수갯수씩 가져다 준다.
    // 일반화 시켜본다.
    
    // 사칙연산의 규칙을 파악하는 것 같다.
    // 연산과정을 생각하면 몫과 나머지의 관계를 구하면 될것 같다.
    // a : 3, b : 2, n : 20인 경우
    // 1. 나눠지는 수 : 20, 나누는 수 : 3, 몫 : 6, 나머지 : 2, 받은 콜라수[6*2]
    // 2. 나눠지는 수 : 12+2, 나누는 수 : 3, 몫 : 4, 나머지 : 2, 받은 콜라수[6*2, 4*2]
    // 3. 나눠지는 수 : 8+2, 나누는 수 : 3, 몫 : 3, 나머지 : 1, 받은 콜라수[6*2, 4*2, 3*2]
    // 4. 나눠지는 수 : 6+1, 나누는 수 : 3, 몫 : 2, 나머지 : 1, 받은 콜라수[6*2, 4*2, 3*2, 2*2]
    // 5. 나눠지는 수 : 4+1, 나누는 수 : 3, 몫 : 1, 나머지 : 2, 받은 콜라수[6*2, 4*2, 3*2, 2*2, 1*2]
    // 6. 나눠지는 수 : 2+2, 나누는 수 : 3, 몫 : 1, 나머지 : 1, 받은 콜라수[6*2, 4*2, 3*2, 2*2, 1*2, 1*2]
    // 7. 나눠지는 수 : 2+1, 나누는 수 : 3, 몫 : 1, 나머지 : 0, 받은 콜라수[6*2, 4*2, 3*2, 2*2, 1*2, 1*2, 1*2]
    // 8. 나눠지는 수 : 2, 나누는 수 : 3, 몫 : 0, 나머지 : 2, 받은 콜라수[6*2, 4*2, 3*2, 2*2, 1*2, 1*2, 1*2], 연산 불가
    // n을 a로 나눴을때 몫에 b를 곱하여 배열에 담고,나머지는 다음 연산에서 배열의 원소에 더하여 다시 연산을 한다.
    // 반복문을 통해 연산을 반복해야 한다. 
    // 연산 마지막에 나눠지는 수를 재할당한다.
    // 일반화
    // 1. 나눠지는 수 : n, 나누는 수: a, 몫 : |n/a|, 나머지 : n%a, 받은 콜라수[|n/a|*b]
    // 2. 나눠지는 수 : |n/a|*b + n%a, 나누는 수: a, 몫 : |(|n/a|*b + n%a)/a|, 나머지 : (|n/a|*b + n%a)%a, 받은 콜라수[|n/a|*b]
    // ... 나눠지는 수가 a보다 작을때 까지 반복한다.
    
    // 반복문 사용 O
    const get=[]
    let value = 0
    while(n>=a){
        value = parseInt(n/a)*b
        get[get.length] = value
        n= value + n%a
    }
    return get.reduce((acc,cur)=> acc+cur,0)
    
    // 반복문 사용 X
    
}